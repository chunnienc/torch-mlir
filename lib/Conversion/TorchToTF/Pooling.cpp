// // #include "torch-mlir/Conversion/TorchToTF/TFLegalizeUtils.h"
// #include "torch-mlir/Conversion/TorchToTF/TorchToTF.h"
// #include "torch-mlir/Conversion/Utils/Utils.h"

// #include "../PassDetail.h"
// #include "PopulatePatterns.h"
// #include "mlir/Dialect/Arith/IR/Arith.h"
// #include "mlir/Dialect/Tensor/IR/Tensor.h"
// #include "mlir/Dialect/Traits.h"
// #include "mlir/IR/Matchers.h"
// #include "mlir/Transforms/DialectConversion.h"
// #include "tensorflow/compiler/mlir/tensorflow/ir/tf_ops.h"
// #include "torch-mlir/Dialect/Torch/IR/TorchOps.h"
// #include "torch-mlir/Dialect/Torch/IR/TorchTypes.h"
// #include "torch-mlir/Dialect/Torch/Utils/Utils.h"
// #include "torch-mlir/Dialect/TorchConversion/IR/TorchConversionDialect.h"
// #include "torch-mlir/Dialect/TorchConversion/Transforms/BackendTypeConversion.h"

// namespace mlir {
// namespace torch {
// namespace torch_to_tf {

// namespace {

// using int32_t = std::int32_t;
// using namespace mlir;
// using namespace mlir::torch;
// using namespace mlir::torch::Torch;



// } // namespace

// void populatePoolingOpPatternsAndLegality(TypeConverter &typeConverter,
//                                           RewritePatternSet &patterns,
//                                           ConversionTarget &target,
//                                           const TorchToTFOptions &options) {}

// } // namespace torch_to_tf
// } // namespace torch
// } // namespace mlir